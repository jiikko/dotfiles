# Forge

専門家エージェントによる高品質な実装・改善スキル。タスク実装とコードレビュー両方に対応。

## アーキテクチャ

```
┌────────────────────────────────────────────────────────────────┐
│                    メイン Claude（オーケストレーター）            │
│  役割: 指示出し、進行管理、最終判断のみ                          │
│  禁止: 直接的なコード分析、レビュー結果の独自解釈                  │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                    Phase N: 専門家エージェント並行実行            │
│  swift-language-expert, swiftui-macos-designer, etc.           │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                    Phase N.x: クロスレビュー                     │
│  各エージェントの出力を別の観点を持つエージェントが検証            │
│  メインClaudeは検証済み結果のみを受け取る                        │
└────────────────────────────────────────────────────────────────┘
```

### メイン Claude の責務

| やること | やらないこと |
|---------|-------------|
| Phase の進行管理 | コードの直接分析 |
| sub agent への指示出し | レビュー結果の独自解釈 |
| ユーザーとの対話 | 専門判断（sub agent に委譲）|
| 最終結果の報告 | 重複排除（統合エージェントに委譲）|

## 使い方

```
/forge [タスク説明 または 対象ファイル/ディレクトリ]
```

例:
- `/forge TextElement に letterSpacing プロパティを追加` → 実装モード
- `/forge バグ #123 を修正` → 実装モード
- `/forge Sources/ViewModels/CanvasViewModel.swift` → レビューモード
- `/forge Sources/Services/` → レビューモード

## モード判定

`$ARGUMENTS` の内容で自動判定:

| 入力パターン | モード | フロー |
|-------------|--------|--------|
| ファイル/ディレクトリパス | レビュー | Phase -1 → 4 → 4.1 → 4.2 → 修正 → 繰り返し |
| それ以外（タスク説明） | 実装 | Phase -1 → 0 → 1 → 1.1 → 1.5 → 2 → 3 → 4 → 4.1 → 4.2 → 繰り返し |

## フロー概要

### 実装モード
```
┌─────────────────────────────────────────────────────────┐
│  Phase -1: 品質モード選択（コスト/品質のバランス確認）    │
├─────────────────────────────────────────────────────────┤
│  Phase 0: 要件確認（ユーザーと対話）                      │
├─────────────────────────────────────────────────────────┤
│  Phase 1: 事前調査 + 類似コード特定（専門家6つ並行）       │
├─────────────────────────────────────────────────────────┤
│  Phase 1.1: クロスレビュー（調査結果の相互検証）          │
├─────────────────────────────────────────────────────────┤
│  Phase 1.5: 設計書作成・ユーザー承認                      │
├─────────────────────────────────────────────────────────┤
│  Phase 2: 実装 + ビルド確認                              │
├─────────────────────────────────────────────────────────┤
│  Phase 3: セルフレビュー（5回）+ テスト実行               │
├─────────────────────────────────────────────────────────┤
│  Phase 4: 専門家レビュー（6つ並行）                       │
├─────────────────────────────────────────────────────────┤
│  Phase 4.1: クロスレビュー（レビュー結果の相互検証）       │
├─────────────────────────────────────────────────────────┤
│  Phase 4.2: 統合レビュー（結果の統合・重複排除）          │
├─────────────────────────────────────────────────────────┤
│  [Phase 4.5: デバッグ支援（エラー発生時のみ）]            │
├─────────────────────────────────────────────────────────┤
│  指摘あり？ ─Yes→ Phase 2 に戻る                         │
│            └No→ 完了                                    │
└─────────────────────────────────────────────────────────┘
```

### レビューモード
```
┌─────────────────────────────────────────────────────────┐
│  Phase -1: 品質モード選択（コスト/品質のバランス確認）    │
├─────────────────────────────────────────────────────────┤
│  Phase 4: 専門家レビュー（6つ並行、選択モードに応じて）   │
├─────────────────────────────────────────────────────────┤
│  Phase 4.1: クロスレビュー（レビュー結果の相互検証）       │
├─────────────────────────────────────────────────────────┤
│  Phase 4.2: 統合レビュー（結果の統合・重複排除）          │
├─────────────────────────────────────────────────────────┤
│  [Phase 4.5: デバッグ支援（エラー発生時のみ）]            │
├─────────────────────────────────────────────────────────┤
│  Phase 5: 修正 + ビルド・テスト確認                       │
├─────────────────────────────────────────────────────────┤
│  指摘あり？ ─Yes→ Phase 4 に戻る                         │
│            └No→ 完了                                    │
└─────────────────────────────────────────────────────────┘
```

### Minimum モード（実装・レビュー共通）
```
┌─────────────────────────────────────────────────────────┐
│  Phase -1: 品質モード選択（Minimum を選択）              │
├─────────────────────────────────────────────────────────┤
│  Phase 0: 要件確認（実装モードのみ）                     │
├─────────────────────────────────────────────────────────┤
│  Phase 1/4: エージェント直列実行（3つを順番に）          │
│    1. Explore（関連コード調査）                          │
│    2. swift-language-expert（言語レビュー）              │
│    3. architecture-reviewer（設計レビュー）              │
│    ※ 各エージェントは前のエージェント完了後に起動        │
├─────────────────────────────────────────────────────────┤
│  Phase 2/5: 実装/修正 + ビルド確認                       │
├─────────────────────────────────────────────────────────┤
│  Phase 3: セルフレビュー（1回のみ）                      │
├─────────────────────────────────────────────────────────┤
│  完了（最大サイクル: 1回）                               │
└─────────────────────────────────────────────────────────┘
```

**Minimum モードの特徴**:
- 🐢 同時に1エージェントのみ起動（並行処理なし）
- 💰 最小コスト（haiku × 3エージェント）
- ⏳ 時間はかかるが確実に低コスト
- 🎯 必須エージェントのみで基本的な品質を確保

### Ultra モード（反復並列思考）★NEW
```
┌─────────────────────────────────────────────────────────┐
│  Phase -1: 品質モード選択（Ultra Opus/Sonnet/Haiku）    │
├─────────────────────────────────────────────────────────┤
│  Phase 0: 要件確認（実装モードのみ）                     │
├─────────────────────────────────────────────────────────┤
│  Phase 1/4: Round 1 - 全エージェント並行分析            │
├─────────────────────────────────────────────────────────┤
│  Phase 4.3: 反復並列思考                                │
│    Round 2: 全結果を入力に再度全員で並行分析             │
│        ↓                                               │
│    収束判定 → 未収束なら Round 3                        │
│        ↓                                               │
│    統合エージェントが全ラウンド結果を統合                │
├─────────────────────────────────────────────────────────┤
│  Phase 1.5: 設計書作成・ユーザー承認（実装モードのみ）   │
├─────────────────────────────────────────────────────────┤
│  Phase 2/5: 実装/修正 + ビルド確認                       │
├─────────────────────────────────────────────────────────┤
│  Phase 3: セルフレビュー                                │
├─────────────────────────────────────────────────────────┤
│  指摘あり？ ─Yes→ Phase 4.3 に戻る                      │
│            └No→ 完了                                   │
└─────────────────────────────────────────────────────────┘
```

**Ultra モードの特徴**:
- 🧠 全エージェントの結果を全員で共有して再分析
- 🔄 最大3ラウンドの反復で深掘り
- 💡 A の発見が B の新仮説を誘発する「発見の連鎖」
- 🎯 原因不明のバグ、状態遷移問題に強い

### クロスレビューの仕組み

```
Phase N の出力:
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ Agent A 結果 │    │ Agent B 結果 │    │ Agent C 結果 │
└──────┬───────┘    └──────┬───────┘    └──────┬───────┘
       │                   │                   │
       ▼                   ▼                   ▼
Phase N.x クロスレビュー:
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ Agent B が   │    │ Agent C が   │    │ Agent A が   │
│ A をレビュー │    │ B をレビュー │    │ C をレビュー │
└──────┬───────┘    └──────┬───────┘    └──────┬───────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────┐
│               統合エージェント（opus）★opus昇格           │
│  - 重複排除                                              │
│  - 矛盾の検出・解決（深い分析）                           │
│  - 優先度付け（根拠に基づく判断）                         │
└─────────────────────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────────────────────┐
│              メイン Claude に検証済み結果を返す           │
└─────────────────────────────────────────────────────────┘
```

---

## Phase -1: 品質モード選択（最初に必ず実行）

forge スキル開始時に、**タスク内容を分析して推奨モードを提案**し、AskUserQuestion ツールで確認する。

### タスク分析と推奨モード判定

タスク内容から以下の観点で複雑さを評価し、推奨モードを決定する：

| 評価観点 | 高複雑度（→ Maximum系） | 中複雑度（→ Balanced/Max Sonnet） | 低複雑度（→ Quick/Minimum） |
|---------|------------------------|----------------------------------|---------------------------|
| **影響範囲** | 複数ファイル/モジュール | 2-3ファイル | 単一ファイル |
| **設計判断** | アーキテクチャ変更、新規設計 | 既存パターンの拡張 | 既存コードの軽微な修正 |
| **リスク** | データ破損、セキュリティ | 機能不具合 | UI微調整、typo修正 |
| **キーワード** | リファクタ、分割、設計、移行 | 追加、拡張、改善 | 修正、調整、更新 |

#### 推奨モード判定ルール

```
【Ultra Opus / Ultra Sonnet を推奨】★NEW
- 「原因不明」「調査」「なぜか動かない」「謎のバグ」を含む
- 過去に Maximum で解決できなかった問題
- 状態遷移、タイミング依存、競合状態が疑われる
- 複数の専門領域が交差する問題（例: AppKit + SwiftUI + 非同期処理）
- 「firstResponder」「ライフサイクル」「状態管理」に関する問題

【Maximum / Maximum Sequential を推奨】
- 「アーキテクチャ」「設計」「リファクタ」「分割」「移行」を含む
- 「セキュリティ」「認証」「暗号化」を含む
- 5ファイル以上の変更が予想される
- 新規機能の設計から実装まで

【Maximum Sonnet / Balanced を推奨】
- 「機能追加」「プロパティ追加」「新規○○」を含む
- 2-4ファイルの変更が予想される
- 既存パターンの踏襲で実装可能

【Quick を推奨】
- 「バグ修正」「fix」「修正」を含む（単純なもの）
- 単一ファイルの変更
- 明確な修正箇所が特定済み

【Minimum を推奨】
- 「typo」「コメント」「ドキュメント」を含む
- 変更が1-2行程度
- リスクが極めて低い
```

### 確認プロンプト

```
タスク: [ユーザーの入力]

📊 タスク分析:
- 影響範囲: [単一ファイル / 複数ファイル / モジュール横断]
- 複雑度: [低 / 中 / 高]
- リスク: [低 / 中 / 高]

💡 推奨モード: [推奨モード名]
   理由: [推奨理由を1-2文で]

質問: 「このモードで進めますか？」

選択肢:
1. ✅ [推奨モード名]（推奨）
   - [モードの特徴]

2. 🔥 Maximum（コスト度外視）
   - 全エージェント opus、クロスレビュー有効、セルフレビュー5回

3. 💎 Maximum Sonnet（高品質・コスト効率）
   - 全エージェント sonnet、クロスレビュー有効、セルフレビュー5回

4. ⚖️ Balanced（バランス重視）
   - コア opus + 補助 sonnet、クロスレビュー有効、セルフレビュー3回

5. ⚡ Quick（スピード重視）
   - 全エージェント sonnet、クロスレビュー省略、セルフレビュー1回

6. 🐢 Minimum（直列・最小コスト）
   - haiku × 3エージェント、直列実行、クロスレビュー省略

7. 🔥🐢 Maximum Sequential（直列・最高品質）
   - 全 opus、直列実行、前エージェントの結果を次に渡す

8. 🧠 Ultra Opus（反芻・最高品質）
   - 全 opus、反復並列思考（最大3ラウンド）、集合知で深掘り

9. 🧠💎 Ultra Sonnet（反芻・コスト効率）
   - 全 sonnet、反復並列思考（最大3ラウンド）、集合知で深掘り

10. 🧠🐢 Ultra Haiku（反芻・最小コスト）
    - 全 haiku、反復並列思考（最大3ラウンド）、集合知で深掘り

11. 🎯 Custom（カスタム設定）
```

### 推奨例

| タスク例 | 推奨モード | 理由 |
|---------|----------|------|
| 「CanvasViewModel をリファクタして責務を分割」 | Maximum | アーキテクチャ変更、高リスク |
| 「TextElement に letterSpacing を追加」 | Max Sonnet | 既存パターン踏襲、中複雑度 |
| 「ボタンの色を変更」 | Quick | 単一ファイル、低リスク |
| 「README の typo 修正」 | Minimum | 極めて低リスク |
| 「認証機能を追加」 | Maximum | セキュリティ関連、高リスク |
| 「ドラッグ時のちらつきを修正」 | Max Sonnet / Balanced | バグ修正だが複数ファイル |
| 「原因不明のバグを調査・修正」 | **Ultra Sonnet** | 複数視点の集合知が必要、根本原因特定が困難 |
| 「firstResponder が効かない問題を調査」 | **Ultra Opus** | 状態遷移の深い分析が必要、複数エージェントの知見を統合 |
| 「パフォーマンス低下の原因を特定」 | **Ultra Sonnet** | 複数の仮説を並行検証、コスト効率も考慮 |

### モード別設定

| 設定項目 | Maximum | Max Sequential | Max Sonnet | Balanced | Quick | Minimum | Ultra Opus | Ultra Sonnet | Ultra Haiku |
|---------|---------|----------------|------------|----------|-------|---------|------------|--------------|-------------|
| **コアエージェント** | opus | opus | sonnet | opus | sonnet | haiku | opus | sonnet | haiku |
| **補助エージェント** | opus | opus | sonnet | sonnet | sonnet | - | opus | sonnet | haiku |
| **統合エージェント** | opus | opus | sonnet | sonnet | haiku | - | opus | sonnet | haiku |
| **クロスレビュー** | あり | あり | あり | あり | なし | なし | なし | なし | なし |
| **反復並列思考** | なし | なし | なし | なし | なし | なし | **あり** | **あり** | **あり** |
| **反復ラウンド数** | - | - | - | - | - | - | 最大3 | 最大3 | 最大3 |
| **セルフレビュー** | 5回 | 5回 | 5回 | 3回 | 1回 | 1回 | 5回 | 5回 | 3回 |
| **設計書作成** | あり | あり | あり | あり | 簡易版 | なし | あり | あり | 簡易版 |
| **最大サイクル** | 5 | 5 | 5 | 3 | 2 | 1 | 5 | 5 | 3 |
| **リファクタ専用エージェント** | あり | あり | あり | なし | なし | なし | あり | あり | なし |
| **エージェント実行方式** | 並行 | **直列** | 並行 | 並行 | 並行 | **直列** | **反復並行** | **反復並行** | **反復並行** |
| **使用エージェント数** | 6-9 | 6-9 | 6-9 | 6 | 6 | 3 | 6-9 | 6-9 | 6 |

### コアエージェント（品質に直結）

- swift-language-expert
- swiftui-macos-designer
- architecture-reviewer
- swiftui-performance-expert
- security-auditor
- swift-concurrency-expert

### Minimum モード必須エージェント（3つのみ）

Minimum モードでは以下の3エージェントのみを**直列**で実行する：

1. **Explore** - 関連コード調査（最初に実行）
2. **swift-language-expert** - 言語観点のレビュー
3. **architecture-reviewer** - 設計観点のレビュー

**直列実行の流れ**:
```
Explore の完了を待つ
    ↓
swift-language-expert の完了を待つ
    ↓
architecture-reviewer の完了を待つ
    ↓
完了
```

**Minimum モードの特徴**:
- 同時に1つのエージェントしか起動しない
- 各エージェントの結果を次のエージェントに渡せる
- コスト最小化（haiku × 3エージェント）
- 時間はかかるが、確実に低コストで処理

### Maximum Sequential モード（直列・最高品質）

Maximum と同じ品質設定だが、全エージェントを**直列**で実行する。

**使用エージェント**: Maximum と同じ（6-9エージェント、全て opus）

**直列実行の流れ**:
```
Phase 1（実装モード）/ Phase 4（レビューモード）:
  Explore の完了を待つ
      ↓
  swift-language-expert の完了を待つ
      ↓
  swiftui-macos-designer の完了を待つ
      ↓
  architecture-reviewer の完了を待つ
      ↓
  swiftui-test-expert の完了を待つ
      ↓
  swiftui-performance-expert の完了を待つ
      ↓
  （条件付きエージェントがあれば続行）
      ↓
  クロスレビュー（直列実行）
      ↓
  統合レビュー
```

**Maximum Sequential の特徴**:
- 🔥 最高品質（Maximum と同等）
- 🐢 同時に1エージェントのみ起動
- 📊 各エージェントの結果を次のエージェントに渡せる
- ⏳ 時間は最もかかるが、最も丁寧な処理
- 💡 前のエージェントの出力を参照した深い分析が可能

**使い分け**:
| シナリオ | 推奨モード |
|---------|----------|
| 素早く高品質な結果が欲しい | Maximum（並行） |
| 時間をかけて徹底的に分析したい | **Maximum Sequential** |
| 前のエージェントの結果を踏まえた分析が必要 | **Maximum Sequential** |
| コストを抑えつつ高品質が欲しい | **Maximum Sonnet** |

### Maximum Sonnet モード（高品質・コスト効率）

Maximum と同じ機能・プロセスだが、全エージェントを **sonnet** で実行する。

**使用エージェント**: Maximum と同じ（6-9エージェント、全て sonnet）

**Maximum Sonnet の特徴**:
- 💎 高品質（Maximum と同じプロセス）
- 💰 コスト効率（sonnet は opus より安価）
- ⚡ 並行実行で高速
- 🔄 クロスレビュー有効
- 📋 セルフレビュー5回
- 🛠️ リファクタ専用エージェントあり

**Maximum vs Maximum Sonnet**:
| 観点 | Maximum | Maximum Sonnet |
|------|---------|----------------|
| 品質 | 最高（opus の深い分析） | 高品質（sonnet の効率的な分析） |
| コスト | 高い | 中程度 |
| 速度 | 並行で高速 | 並行で高速 |
| 推奨シーン | 複雑な設計判断、重要な機能 | 一般的な機能実装、バグ修正 |

### Ultra モード（反復並列思考）★NEW

Ultra モードは**反芻（Iterative Collective Intelligence）**パターンを採用。
全エージェントの結果を共有し、再度全員で分析することで、見落としや新たな発見を促す。

**反復並列思考の仕組み**:
```
Round 1: 全エージェントが並行で独立分析
              ↓
         全員の結果を集約
              ↓
Round 2: 全員が「Round 1 の全結果」を入力として再分析
              ↓
         （収束条件を満たすまで or 最大3ラウンド）
              ↓
Round N: 統合エージェントが最終結果をまとめる
```

**収束条件**:
- 新しい指摘/発見が出なくなった
- 全エージェントが同じ結論に達した
- 最大ラウンド数（3回）に達した

**Ultra モードの3バリエーション**:

| 項目 | Ultra Opus | Ultra Sonnet | Ultra Haiku |
|------|------------|--------------|-------------|
| **モデル** | 全 opus | 全 sonnet | 全 haiku |
| **コスト** | 最高（opus × エージェント数 × ラウンド数） | 中程度 | 最小 |
| **分析深度** | 最深（複雑な状態遷移も追跡） | 深い | 基本的 |
| **推奨シーン** | 原因不明の難解バグ、状態遷移問題 | 一般的なデバッグ、複数視点が必要 | 軽いデバッグ、コスト重視 |

**使い分け**:
| シナリオ | 推奨 Ultra モード |
|---------|------------------|
| Maximum で解決できなかった問題 | Ultra Opus |
| firstResponder、ライフサイクル問題 | Ultra Opus |
| 競合状態、タイミング依存バグ | Ultra Opus / Ultra Sonnet |
| 複数視点での分析が欲しい | Ultra Sonnet |
| コストを抑えつつ集合知を活用 | Ultra Haiku |

**Maximum vs Ultra の違い**:
| 観点 | Maximum | Ultra |
|------|---------|-------|
| エージェント間の情報共有 | クロスレビュー（ペア間のみ） | **全員の結果を全員に共有** |
| 分析の深さ | 1回の分析 | **複数ラウンドで深掘り** |
| 発見の連鎖 | 限定的 | **A の発見が B の新仮説を誘発** |
| 矛盾の解消 | 統合エージェントに委任 | **ラウンドを重ねて自然収束** |
| コスト | エージェント数 × 1 | エージェント数 × ラウンド数 |

### 補助エージェント

- research-assistant
- Explore
- swiftui-test-expert
- data-persistence-expert
- macos-system-integration-expert
- image-editing-expert

### Maximum 専用エージェント（リファクタリング強化）

Maximum モード選択時のみ、以下のエージェントを追加で起動する：

| エージェント | 用途 | 起動タイミング |
|-------------|------|---------------|
| dependency-analyzer | 変更の影響範囲分析、依存関係マッピング | Phase 1（常時）、Phase 4（レビュー時） |
| refactoring-patterns | 安全なリファクタリング手順の設計 | Phase 1（リファクタ系タスク時） |
| test-coverage-advisor | テストギャップ分析、カバレッジ戦略 | Phase 1（常時）、Phase 4（常時） |

### モード適用

選択されたモードに基づいて、以降の Phase で使用するエージェントのモデルを決定する。
以降のドキュメント内のモデル指定は Maximum モードの場合を記載している。
Balanced/Quick モードの場合は上記テーブルに従って読み替えること。

---

## Phase 0: 要件確認（実装モードのみ）

実装前に、AskUserQuestion ツールで要件を明確化する。

### 確認項目

```
質問: 「以下の要件で正しいですか？」

タスク: [ユーザーの入力]

確認事項:
1. 目的: [推測した目的]
2. スコープ: [影響範囲の推測]
3. 期待する動作: [具体的な動作]
4. 制約: [あれば]

選択肢:
1. はい、この要件で進めてください
2. 要件を修正したい（詳細を入力）
3. 不明点があるので質問したい
```

### 要件が曖昧な場合

以下のパターンでは**必ず確認**する:

| 曖昧なパターン | 確認すべき内容 |
|---------------|---------------|
| 「〜を追加」 | どこに？どんな形式で？ |
| 「〜を改善」 | 具体的に何を？どの程度？ |
| 「〜のバグを修正」 | 再現手順は？期待動作は？ |
| 「〜を最適化」 | 何を基準に？許容範囲は？ |

---

## Phase 1: 事前調査 + 類似コード特定（実装モードのみ）

最低6つの専門家エージェントを**並行起動**し、実装に必要な情報を収集する。

> **Minimum モードの場合**: 3エージェントのみを**直列実行**する。詳細は「Minimum モード必須エージェント」を参照。
>
> **Maximum Sequential モードの場合**: 全エージェントを**直列実行**する。詳細は「Maximum Sequential モード」を参照。

### 必須エージェント（6つ）

```
1. swift-language-expert (model: opus) ★opus昇格
   prompt: "以下のタスクを実装するために必要な Swift 言語の知識を調査してください。
   - 関連する言語機能（async/await, actor, protocol 等）
   - メモリ管理の考慮点
   - エラーハンドリングパターン
   タスク: [タスク説明]
   既存コードベースの関連部分も確認し、実装方針を提案してください。"

2. swiftui-macos-designer (model: opus) ★opus昇格
   prompt: "以下のタスクを実装するために必要な SwiftUI/macOS の知識を調査してください。
   - 関連する View/State パターン
   - 既存の UI コンポーネントとの整合性
   - macOS HIG への準拠
   タスク: [タスク説明]
   既存の View 構造を確認し、実装方針を提案してください。"

3. research-assistant (model: opus) ★opus昇格
   prompt: "以下のタスクに関するベストプラクティスと公式ドキュメントを**徹底調査**してください。
   - Apple 公式ドキュメント
   - 推奨される実装パターン
   - 一般的な落とし穴と回避策
   - **複数ソースのクロスチェック**
   - **反論や代替案の検討**
   タスク: [タスク説明]
   参考リンクと共に、**信頼性評価を含めて**報告してください。"

4. Explore (model: opus) ★opus昇格、類似コード特定強化
   prompt: "以下のタスクに関連する既存コードを**徹底的に**調査してください。

   【必須】類似機能の特定:
   - 同様の機能を持つ既存コードを特定
   - そのコードの実装パターンを詳細に報告
   - 再利用可能な部分を明示

   【必須】影響範囲:
   - 変更が必要なファイル一覧
   - 依存関係のあるファイル
   - 既存テストへの影響

   タスク: [タスク説明]

   **重要**: 類似コードが見つかった場合、そのファイルパスと該当行番号を
   必ず報告してください。実装時にそのパターンを参考にします。"

5. architecture-reviewer (model: opus) ★必須
   prompt: "以下のタスクのアーキテクチャ観点での設計方針を提案してください。
   - 適切なレイヤー配置（View/ViewModel/Model/Service）
   - 依存方向の確認
   - 責務分離の妥当性
   - テスタビリティ
   タスク: [タスク説明]
   既存アーキテクチャとの整合性を確認し、推奨する設計を報告してください。"

6. swiftui-test-expert (model: opus) ★opus昇格
   prompt: "以下のタスクのテスト戦略を**徹底的に**提案してください。
   - 必要なユニットテスト
   - リグレッションテスト（既存機能の保護）
   - **エッジケースの網羅的な検討**
   - **非同期処理のテストパターン**
   - **潜在的なフレーキーテストのリスク分析**
   タスク: [タスク説明]
   既存テスト（ThumbnailThumbTests/）との整合性も確認してください。"
```

### 条件付き必須エージェント

以下は条件に該当する場合、**必ず追加**する：

| 条件 | 追加エージェント | モデル |
|------|-----------------|--------|
| View/UI 変更を含む | swiftui-performance-expert | opus |
| async/await, actor, Task を含む | swift-concurrency-expert | opus |
| ファイル操作、外部入力、API 通信 | security-auditor | opus |

### 追加エージェント（タスク内容に応じて選択）

| タスク内容 | 追加エージェント | モデル |
|-----------|-----------------|--------|
| AppKit 連携あり | appkit-swiftui-integration-expert | opus |
| データ保存あり | data-persistence-expert | opus |
| システム API 使用 | macos-system-integration-expert | opus |
| UI エディタ関連 | image-editing-expert | opus |

### Maximum 専用エージェント（Phase 1）

Maximum モード選択時は、以下のエージェントを**必ず追加で並行起動**する：

```
7. dependency-analyzer (model: opus) ★Maximum専用
   prompt: "以下のタスクの影響範囲を分析してください。
   - 変更対象ファイルの依存関係マッピング
   - 変更による波及効果の予測
   - 循環依存の有無
   - 影響を受けるテストファイルの特定
   タスク: [タスク説明]
   影響範囲レポートを作成してください。"

8. test-coverage-advisor (model: opus) ★Maximum専用
   prompt: "以下のタスクのテストカバレッジ状況を分析してください。
   - 既存テストのカバレッジ評価
   - テストギャップの特定
   - リファクタリング前に追加すべきテスト
   - リグレッション防止戦略
   タスク: [タスク説明]
   テスト戦略レポートを作成してください。"

9. refactoring-patterns (model: opus) ★Maximum専用、リファクタ系タスクのみ
   条件: タスクが「リファクタ」「分割」「抽出」「移動」「整理」を含む場合
   prompt: "以下のリファクタリングタスクの安全な実行手順を設計してください。
   - 適用すべきリファクタリングパターンの選定
   - 段階的な実行ステップ
   - 各ステップのロールバック方法
   - 破壊的変更の回避策
   タスク: [タスク説明]
   リファクタリング計画を作成してください。"
```

**Note**: 各エージェントの詳細なプロンプトは `.claude/agents/` ディレクトリの定義ファイルを参照。

---

## Phase 1.1: クロスレビュー（実装モードのみ）★NEW

Phase 1 の各エージェント出力を、**別の観点を持つエージェントが検証**する。

### クロスレビューのペアリング

| 元エージェント | レビュー担当 | 代替（不在時） | 検証観点 |
|---------------|-------------|--------------|---------|
| swift-language-expert | architecture-reviewer | - | 言語機能の選択が設計に適合しているか |
| swiftui-macos-designer | swiftui-performance-expert | architecture-reviewer | UI 設計がパフォーマンスに影響しないか |
| architecture-reviewer | swift-language-expert | - | 設計が Swift の言語機能を活かしているか |
| swiftui-test-expert | Explore | - | テスト戦略が既存パターンと整合しているか |
| Explore | swiftui-test-expert | - | 特定した類似コードのテストカバレッジは十分か |
| research-assistant | security-auditor | swift-language-expert | 調査したベストプラクティスにセキュリティ懸念はないか |

**Note**: `swiftui-performance-expert` と `security-auditor` は条件付き必須のため、起動していない場合は代替エージェントがレビューを担当する。

### クロスレビュー プロンプト

```
以下は [元エージェント名] の調査結果です。
[観点] の観点から検証し、以下を報告してください。

検証対象:
[元エージェントの出力全文]

検証項目:
1. 事実の正確性: 記載内容に誤りはないか
2. 見落とし: 重要な考慮点が漏れていないか
3. リスク: 提案された方針に潜在的なリスクはないか
4. 補足: 追加で考慮すべき点はあるか

出力形式:
- ✅ 検証OK: [問題なしの項目]
- ⚠️ 要注意: [注意が必要な項目と理由]
- ❌ 要修正: [修正が必要な項目と修正案]
- 💡 補足: [追加の考慮点]
```

### 統合エージェントによる結果統合

クロスレビュー完了後、**統合エージェント（sonnet）**を起動して結果を統合:

```
統合エージェント プロンプト:

以下は Phase 1 の調査結果と、それぞれのクロスレビュー結果です。
これらを統合し、メイン Claude に報告するための最終結果を作成してください。

【統合対象】
[各エージェントの出力 + クロスレビュー結果]

【統合ルール】
1. 重複する情報を排除
2. 矛盾がある場合は両方の見解を記載し、推奨を明示
3. ⚠️ 要注意 と ❌ 要修正 の項目を優先的に報告
4. 各情報の出典（エージェント名）を保持

【出力形式】
## 統合済み調査結果

### 1. 実装方針（合意済み）
[全エージェントが合意した方針]

### 2. 要注意事項
[クロスレビューで指摘された注意点]

### 3. 参考にする類似コード
[Explore + クロスレビューで検証済み]

### 4. 未解決の矛盾
[エージェント間で見解が分かれた点]
```

---

## Phase 1.5: 設計書作成・ユーザー承認（実装モードのみ）

調査結果を元に設計書を作成し、実装前にユーザーの承認を得る。

### 設計書フォーマット

```markdown
## 設計書: [タスク名]

### 1. 概要
[タスクの目的と期待される結果]

### 2. 参考にする類似コード
| ファイル | 行番号 | 参考ポイント |
|---------|--------|-------------|
| [パス] | [N-M行] | [何を参考にするか] |

### 3. 変更ファイル一覧
| ファイル | 変更内容 | 新規/修正 |
|---------|---------|----------|
| [パス] | [概要] | 新規/修正 |

### 4. 実装方針
1. [ステップ1]
2. [ステップ2]
...

### 5. テスト方針
- [ ] [テスト1]
- [ ] [テスト2]

### 6. リスク・懸念点
- [あれば記載]
```

### ユーザー承認

```
質問: 「この設計で実装を進めてよいですか？」

選択肢:
1. はい、この設計で進めてください
2. 設計を修正したい
3. 追加の調査が必要
4. キャンセル
```

---

## Phase 2: 実装 + ビルド確認（実装モードのみ）

Phase 1 の調査結果と Phase 1.5 の設計書に基づき、実装を行う。

### 実装手順

1. **類似コードを開く**: Explore で特定した類似コードを Read で読み込む
2. **パターンを踏襲**: 類似コードの命名規則、構造、エラーハンドリングを参考にする
3. **段階的に実装**: 設計書のステップに従って順番に実装
4. **都度ビルド確認**: 変更後は `make build` で即座に確認

### 実装時のチェックリスト

```markdown
□ CLAUDE.md のルールに準拠
  - 強制アンラップ禁止
  - canvases[0] 等の直接アクセス禁止
  - @State は private
  - メインスレッド制約を遵守

□ 類似コードとの一貫性
  - 命名規則を合わせる
  - ファイル配置を合わせる
  - エラーハンドリング方式を合わせる

□ モデル変更時の追加タスク（該当する場合）
  - ラウンドトリップテストの更新
  - docs/elements.md の更新
  - docs/api-design.md の更新
```

### ビルド確認（必須）

```bash
# 実装後、必ず実行
make build
```

**ビルドが失敗した場合**: エラーを修正してから次に進む。ビルドが通らない状態で Phase 3 に進まない。

### 実装中の専門家相談（難所で活用）

実装中に詰まった場合、**該当分野の専門家エージェントを呼び出す**。

| 詰まった内容 | 呼び出すエージェント |
|-------------|---------------------|
| actor/async の設計 | swift-concurrency-expert |
| View の再描画問題 | swiftui-performance-expert |
| 設計・責務分離の判断 | architecture-reviewer |
| AppKit 統合の問題 | appkit-swiftui-integration-expert |
| テストの書き方 | swiftui-test-expert |
| エラーの原因特定 | debugger |

---

## Phase 3: セルフレビュー（実装モードのみ、5回）

実装完了後、以下の観点で**5回**セルフレビューを実施する。

### セルフレビュー 1回目: 要件充足

```markdown
チェック項目:
- [ ] Phase 0 で確認した要件をすべて満たしているか
- [ ] 設計書の「期待される結果」を達成しているか
- [ ] エッジケースを考慮しているか
```

### セルフレビュー 2回目: 正確性

```markdown
チェック項目:
- [ ] ロジックは正しいか
- [ ] エラーハンドリングは適切か
- [ ] nil/optional の扱いは安全か
- [ ] 境界値は正しく処理されているか
```

### セルフレビュー 3回目: 類似コードとの一貫性

```markdown
チェック項目:
- [ ] Phase 1 で特定した類似コードと同じパターンを使っているか
- [ ] 命名規則は既存コードと一致しているか
- [ ] ファイル配置は適切か
```

### セルフレビュー 4回目: 品質

```markdown
チェック項目:
- [ ] コードは読みやすいか
- [ ] 重複コードはないか
- [ ] 単一責任原則を守っているか
- [ ] 過剰な実装（YAGNI違反）はないか
```

### セルフレビュー 5回目: プロジェクトルール + ビルド・テスト

```markdown
チェック項目:
- [ ] CLAUDE.md のルールに違反していないか
- [ ] SwiftLint エラー/警告はないか
```

**必須コマンド実行**:
```bash
make lint   # SwiftLint チェック
make build  # ビルド確認
make test   # テスト実行
```

**すべて通過してから** Phase 4 に進む。失敗した場合はその場で修正。

---

## Phase 4: 専門家レビュー（両モード共通）

> **Minimum モードの場合**: 3エージェントのみを**直列実行**する。Phase 4.1（クロスレビュー）と Phase 4.2（統合レビュー）は省略。
>
> **Maximum Sequential モードの場合**: 全エージェントを**直列実行**する。Phase 4.1, 4.2 も直列で実行。

### ファイル内容に基づくエージェント選択

**重要**: ファイルパスのパターンマッチだけでなく、**実際のファイル内容を読み取って**適切なエージェントを選択する。

#### 判定手順

1. 対象ファイルを Read ツールで読み込む
2. 以下のキーワード/パターンを検出してエージェントを決定：

| 検出パターン | 追加エージェント |
|-------------|-----------------|
| `NSViewRepresentable`, `NSHostingView`, `makeNSView` | appkit-swiftui-integration-expert |
| `Canvas`, `Layer`, `Tool`, エディタ関連 | image-editing-expert |
| `Codable`, `JSONEncoder`, `FileManager`, `SwiftData` | data-persistence-expert |
| `URLSession`, `FileHandle`, ユーザー入力処理 | security-auditor |
| `NSStatusItem`, `Keychain`, `SecurityScoped` | macos-system-integration-expert |
| `@State`, `@Observable`, View 構造体 | swiftui-macos-designer |
| `async`, `await`, `actor`, `Task` | swift-concurrency-expert |

### 必須エージェント（6つ）

```
1. swift-language-expert (model: opus) ★opus
   prompt: "以下のコードを Swift 言語の観点からレビューしてください。
   - async/await, actor の使い方
   - メモリ管理（retain cycle, weak/unowned）
   - エラーハンドリング
   - プロトコル/ジェネリクスの設計

   **プロジェクト固有ルール（CLAUDE.md より）**:
   - 強制アンラップ (force unwrap) は禁止
   - `canvases[0]` 等の直接アクセス禁止（`.first` を使用）
   - `@unchecked Sendable` 使用時は安全性の理由をコメントで説明
   - ImageRenderer, NSHostingView はメインスレッドでのみ使用可

   対象: [ファイルパス]
   問題点と改善案を箇条書きで報告してください。"

2. swiftui-macos-designer (model: opus) ★opus
   prompt: "以下のコードを SwiftUI/macOS の観点からレビューしてください。
   - State管理（@State, @StateObject, @Observable）
   - View の再描画パフォーマンス
   - macOS HIG 準拠
   - NSViewRepresentable の使い方

   **プロジェクト固有ルール（CLAUDE.md より）**:
   - `@State` プロパティは private にすべき
   - `@ObservedObject` の直接初期化禁止（`@StateObject` を使用）
   - `.id(UUID())` 禁止（安定した識別子を使用）

   対象: [ファイルパス]
   問題点と改善案を箇条書きで報告してください。"

3. swiftui-test-expert (model: opus) ★opus昇格
   prompt: "以下のコードをテスト戦略の観点から**徹底的に**レビューしてください。
   - テストカバレッジ戦略
   - リグレッションテスト
   - 非同期処理のテストパターン
   - **エッジケースの網羅的検討**
   - **フレーキーテストのリスク分析**
   対象: [ファイルパス]
   問題点に対するテスト戦略を箇条書きで報告してください。"

4. architecture-reviewer (model: opus) ★opus
   prompt: "以下のコードをアーキテクチャ観点から**徹底的に**レビューしてください。
   - レイヤー配置の適切性
   - 依存方向
   - 責務分離
   - テスタビリティ
   - **将来的な拡張性**
   対象: [ファイルパス]
   問題点と改善案を箇条書きで報告してください。"

5. Explore (model: opus) ★opus昇格
   prompt: "以下のコードに関連する既存コードを**徹底的に**調査してください。
   - 類似機能の実装箇所
   - 影響を受けるファイル
   - 既存のテストパターン
   - **潜在的な影響範囲の深掘り**
   対象: [ファイルパス]
   関連ファイルと影響範囲を報告してください。"

6. swiftui-performance-expert (model: opus) ★opus、常時必須に昇格
   prompt: "以下のコードのパフォーマンスをレビューしてください。
   - 不要な再描画
   - メモリ使用量
   - 重い処理のメインスレッドブロック
   対象: [ファイルパス]
   パフォーマンス上の問題点を報告してください。"
```

### 条件付き必須エージェント

| 条件 | 追加エージェント | モデル |
|------|-----------------|--------|
| async/await, actor, Task を含む | swift-concurrency-expert | opus |
| ファイル操作、外部入力、API 通信 | security-auditor | opus |

**Note**: Phase 1 の条件付き必須エージェントとの違い:
- `swiftui-performance-expert` は Phase 4 では常時必須に昇格済み（上記リストから除外）

### Maximum 専用エージェント（Phase 4）

Maximum モード選択時は、以下のエージェントを**追加で並行起動**する：

```
7. dependency-analyzer (model: opus) ★Maximum専用
   prompt: "以下のコードの依存関係を分析し、レビュー観点を提供してください。
   - ファイル間の結合度評価
   - 循環依存の検出
   - 変更が他のファイルに与える影響
   対象: [ファイルパス]
   依存関係の問題点を報告してください。"

8. test-coverage-advisor (model: opus) ★Maximum専用
   prompt: "以下のコードのテストカバレッジをレビューしてください。
   - テストギャップの特定
   - 追加すべきテストケース
   - リグレッションリスクの評価
   対象: [ファイルパス]
   テストに関する推奨事項を報告してください。"
```

---

## Phase 4.1: クロスレビュー（両モード共通）★NEW

Phase 4 の各エージェント出力を、**別の観点を持つエージェントが検証**する。

### クロスレビューのペアリング（レビュー用）

| 元エージェント | レビュー担当 | 検証観点 |
|---------------|-------------|---------|
| swift-language-expert | architecture-reviewer | 言語の指摘が設計と整合しているか |
| swiftui-macos-designer | swiftui-performance-expert | UI の指摘がパフォーマンスを考慮しているか |
| architecture-reviewer | swift-language-expert | 設計の指摘が言語制約を考慮しているか |
| swiftui-performance-expert | swiftui-macos-designer | パフォーマンス改善がUX を損なわないか |
| swiftui-test-expert | Explore | テストの指摘が既存パターンと整合しているか |
| Explore | swiftui-test-expert | 関連コードの指摘にテスト観点が含まれているか |

**Note**: Phase 4 では `swiftui-performance-expert` は常時必須のため、代替は不要。`swift-concurrency-expert` と `security-auditor` が条件付きで追加された場合は、上記ペアリングに加えて相互レビューを行う。

### クロスレビュー プロンプト（レビュー用）

```
以下は [元エージェント名] のコードレビュー結果です。
[観点] の観点から検証し、以下を報告してください。

レビュー対象ファイル: [ファイルパス]

元レビュー結果:
[元エージェントの出力全文]

検証項目:
1. 指摘の妥当性: 各指摘は正当か、過剰反応ではないか
2. 見落とし: 重要な問題が見落とされていないか
3. 修正案の適切性: 提案された修正は副作用を起こさないか
4. 優先度の妥当性: 重要度の判断は適切か

出力形式:
- ✅ 同意: [妥当と判断した指摘]
- ⚠️ 要検討: [追加の考慮が必要な指摘と理由]
- ❌ 過剰: [過剰反応と判断した指摘と理由]
- 💡 追加指摘: [元レビューが見落とした問題]
```

---

## Phase 4.2: 統合レビュー（両モード共通）★NEW

クロスレビュー完了後、**統合エージェント（opus）**を起動して結果を統合。★opus昇格

### 統合エージェント プロンプト

```
以下は Phase 4 のレビュー結果と、Phase 4.1 のクロスレビュー結果です。
これらを統合し、メイン Claude に報告するための最終結果を作成してください。

【統合対象】
[各エージェントのレビュー出力 + クロスレビュー結果]

【統合ルール】
1. 重複する指摘を排除（同じ行・同じ問題への指摘）
2. クロスレビューで「⚠️ 要検討」とされた指摘には注釈を追加
3. クロスレビューで「❌ 過剰」とされた指摘は除外（理由と共に記録）
4. 「💡 追加指摘」を統合結果に含める
5. 各指摘の出典（エージェント名）を保持
6. 優先度順にソート（High → Medium → Low）

【出力形式】
## 統合済みレビュー結果

### 🔴 High Priority（即時対応）
| # | 指摘内容 | ファイル:行 | 指摘元 | クロスレビュー |
|---|---------|------------|--------|--------------|
| 1 | [内容] | [パス:行] | [エージェント] | ✅ 同意 |

### 🟡 Medium Priority（推奨）
[同様のテーブル]

### 🟢 Low Priority（任意）
[同様のテーブル]

### ⏸️ 除外された指摘（過剰と判断）
| # | 元の指摘 | 除外理由 | 判断者 |
|---|---------|---------|--------|

### ⚠️ 要検討（エージェント間で意見が分かれた）
| # | 指摘内容 | 賛成 | 反対 | 論点 |
|---|---------|-----|------|------|
```

### 統合ルールの詳細

#### 重複排除の基準

```
同じ指摘とみなす条件:
1. 同じファイル・同じ行番号
2. AND 同じ問題カテゴリ（例: retain cycle, performance, etc.）

例:
- [swift-language-expert] 42行目: retain cycle の可能性
- [swiftui-macos-designer] 42行目: クロージャでの self キャプチャに注意
→ 統合: 42行目: retain cycle（self キャプチャ）
  指摘元: swift-language-expert, swiftui-macos-designer
  クロスレビュー: ✅ 両者とも同意
```

#### 矛盾の解決

```
矛盾がある場合の処理:
1. 両方の見解を「⚠️ 要検討」セクションに記載
2. 各エージェントの根拠を併記
3. メイン Claude はユーザーに判断を委ねる（独自判断しない）
```

---

## Phase 4.3: 反復並列思考（Ultra モードのみ）★NEW

Ultra モード選択時は、Phase 4.1/4.2 の代わりにこのフェーズを実行する。

### フロー

```
┌─────────────────────────────────────────────────────────────────────┐
│  Round 1: 全エージェント並行実行（Phase 4 と同じ）                    │
│    - 各エージェントが独立して分析                                    │
│    - 結果を収集                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  Round 2: 再分析（全員の Round 1 結果を入力）                        │
│    - 同じエージェントを再度並行起動                                  │
│    - 他エージェントの発見を踏まえて再分析                            │
├─────────────────────────────────────────────────────────────────────┤
│  収束判定:                                                          │
│    - 新しい発見がある？ → Round 3 へ                                │
│    - 新しい発見がない or 最大ラウンド数 → 統合へ                     │
├─────────────────────────────────────────────────────────────────────┤
│  統合: 全ラウンドの結果を統合エージェントがまとめる                   │
└─────────────────────────────────────────────────────────────────────┘
```

### Round 2+ の再分析プロンプト

```
以下は他の専門家エージェントの分析結果（Round [N-1]）です。
これらを踏まえて、あなたの専門領域から**再分析**してください。

【他エージェントの分析結果】
[全エージェントの前ラウンド出力]

【あなたの前ラウンド分析】
[このエージェントの前ラウンド出力]

【再分析の観点】
1. **新たな発見**: 他エージェントの指摘を受けて気づいた新しい問題
2. **見解の変化**: 前ラウンドの自分の分析で修正すべき点
3. **深掘り**: 他エージェントの指摘をさらに深掘りした分析
4. **仮説の検証**: 他エージェントの仮説に対する検証結果
5. **合意事項**: 全員が同意している点の確認

【出力形式】
## Round [N] 再分析結果

### 🆕 新たな発見
[他エージェントの指摘を受けて気づいた点]

### 🔄 見解の更新
[前ラウンドからの変更点]

### 🔍 深掘り分析
[他エージェントの指摘をさらに発展させた分析]

### ✅ 合意事項
[全エージェントで一致している点]

### ❓ 未解決の疑問
[さらに調査が必要な点]
```

### 収束判定

各ラウンド終了後、以下の条件で収束を判定：

| 条件 | 判定 |
|------|------|
| 全エージェントから「新たな発見なし」 | **収束** |
| 「合意事項」が全エージェントで一致 | **収束** |
| 最大ラウンド数（3回）に到達 | **強制終了** |
| 「未解決の疑問」が減少傾向 | 継続を検討 |
| 「未解決の疑問」が増加傾向 | 1ラウンド追加して終了 |

### 統合プロンプト（Ultra モード用）

```
以下は全 [N] ラウンドにわたる反復分析の結果です。
これらを統合し、最終的な分析結果を作成してください。

【全ラウンドの結果】
[Round 1 〜 Round N の全出力]

【統合ルール】
1. ラウンドを重ねて収束した結論を優先
2. 複数エージェントが同意した指摘を高優先度に
3. 最終ラウンドで「未解決」とされた点は「要追加調査」として記録
4. 仮説の変遷（どう深まったか）を記録

【出力形式】
## Ultra モード統合結果

### 🎯 確定した根本原因
[全エージェントが合意した原因]

### 📊 分析の変遷
| ラウンド | 主要な発見 | 変化点 |
|---------|-----------|--------|
| Round 1 | [初期仮説] | - |
| Round 2 | [深掘り結果] | [何が変わったか] |
| Round 3 | [最終結論] | [収束した点] |

### 🔴 High Priority 対応
[修正すべき点]

### ❓ 追加調査が必要
[未解決の疑問]

### 💡 副次的な発見
[当初のタスク以外で発見された問題]
```

---

## Phase 4.5: デバッグ支援（エラー発生時）

レビューで**ランタイムエラーやクラッシュ**が報告された場合、debugger エージェントを起動する。

### 起動条件

- テスト実行時にエラーが発生
- ビルドは通るが実行時にクラッシュ
- 原因不明の挙動

### debugger プロンプト

```
以下のエラーを調査してください。

エラー内容:
[エラーメッセージ/スタックトレース]

発生箇所:
[ファイル:行番号]

再現手順:
[手順]

関連する変更:
[今回の変更内容]

根本原因を特定し、修正案を提案してください。
```

### クラッシュログの確認

macOS アプリがクラッシュした場合:
```bash
ls ~/Library/Logs/DiagnosticReports/ | grep -i thumbnail
cat ~/Library/Logs/DiagnosticReports/ThumbnailThumb-*.ips | head -200
```

---

## Phase 5: 修正と収束（両モード共通）

### 対話フロー

レビュー結果を報告した後、AskUserQuestion ツールで対応方針を確認：

```
質問: 「レビュー結果に基づいて、どのように対応しますか？」

選択肢:
1. 高優先度の指摘をすべて修正する
2. 指摘ごとに個別に確認する
3. 今回は修正しない（レポートのみ）
4. Issue を作成して後で対応する
```

### 修正後の確認（必須）

```bash
make lint   # SwiftLint チェック
make build  # ビルド確認
make test   # テスト実行（リグレッション確認）
```

**すべて通過してから**再レビューに進む。

### 収束条件

- 全エージェントから「指摘なし」が返ってきたら完了
- または、残りの指摘がすべて「スキップ」または「Issue として記録」された場合

### 最大サイクル数

**5サイクル**を上限とする。5サイクルでも収束しない場合:

```
質問: 「5サイクル実行しましたが、以下の指摘が残っています。どう対応しますか？」

選択肢:
1. 継続する（さらに5サイクル）
2. 残りの指摘を Issue として記録し、完了とする
3. 中断する
```

### 矛盾する指摘への対応

Phase 4.2 の「矛盾の解決」ルールに従う。

---

## 連携機能

### test-runner 連携

テスト追加が推奨された場合、レビュー完了後に test-runner エージェントを起動：

1. swiftui-test-expert の結果から「テスト追加推奨」の項目を抽出
2. ユーザーに確認: 「テストを追加・実行しますか？」
3. 承諾された場合: test-runner でテスト実行

### perf-analysis 連携

パフォーマンス懸念が検出された場合、`/perf-analysis` との連携を提案：

- 大量のループ処理
- 重い計算（画像処理、レンダリング）
- View の頻繁な再描画
- メインスレッドブロッキング

### Issue 作成

重要な問題点が見つかった場合、`issues/` ディレクトリへの記録を提案。

---

## 完了レポート

```markdown
## Forge 完了レポート

### 対象
[タスク説明 or ファイル/ディレクトリ]

### モード
[実装 / レビュー]

### 実施サイクル数
[N] サイクル

### 参考にした類似コード
- [ファイル:行番号]: [何を参考にしたか]

### 変更ファイル
- [ファイルパス]: [変更概要]

### 修正した指摘
- [指摘1]: [修正内容]

### スキップした指摘
- [指摘]: [理由]

### Issue として記録
- [Issue番号]: [指摘内容]

### 最終確認
- [ ] make lint 通過
- [ ] make build 通過
- [ ] make test 通過
- [ ] ドキュメント更新（該当する場合）
```

---

## 注意事項

### メイン Claude の原則（オーケストレーター）

**重要**: メイン Claude は「sub agent の結果をそのまま信頼する」のが原則。
sub agent の出力に疑問がある場合は、**別の sub agent にクロスレビューさせる**。

（詳細は「アーキテクチャ > メイン Claude の責務」を参照）

### クロスレビューの原則

- **必ず実施**: Phase 1.1 と Phase 4.1 は省略しない
- **ペアリング厳守**: 指定されたペアでクロスレビューを行う
- **統合エージェント必須**: クロスレビュー後は必ず統合エージェントを起動
- **メイン Claude は統合結果のみ受け取る**: 個別結果を直接解釈しない

### Minimum モードの注意事項

- **直列実行を厳守**: エージェントは1つずつ順番に起動する（並行起動禁止）
- **3エージェントのみ**: Explore → swift-language-expert → architecture-reviewer
- **クロスレビュー省略**: Phase 4.1, 4.2 はスキップ
- **設計書省略**: Phase 1.5 はスキップ
- **1サイクルで終了**: 繰り返しなし、指摘があれば手動で対応

### Maximum Sequential モードの注意事項

- **直列実行を厳守**: エージェントは1つずつ順番に起動する（並行起動禁止）
- **全エージェント使用**: Maximum と同じエージェント構成（6-9エージェント）
- **クロスレビュー有効**: Phase 4.1, 4.2 も直列で実行
- **設計書作成あり**: Phase 1.5 も実行
- **前エージェントの結果を活用**: 各エージェントに前のエージェントの出力を渡す

### Maximum Sonnet モードの注意事項

- **全て sonnet**: opus 指定の箇所を全て sonnet に読み替える
- **Maximum と同じプロセス**: フェーズ、エージェント数、クロスレビューは同じ
- **コスト効率重視**: 品質と速度を維持しつつコストを削減
- **リファクタ専用エージェントあり**: dependency-analyzer, test-coverage-advisor, refactoring-patterns を使用

### Ultra モードの注意事項★NEW

- **Phase 4.1/4.2 をスキップ**: Ultra モードでは Phase 4.3（反復並列思考）を代わりに実行
- **コスト注意**: エージェント数 × ラウンド数のコストがかかる
  - Ultra Opus: 最大 6-9 × 3 = 27 回の opus 呼び出し
  - Ultra Sonnet: 最大 6-9 × 3 = 27 回の sonnet 呼び出し
  - Ultra Haiku: 最大 6 × 3 = 18 回の haiku 呼び出し
- **収束判定を厳密に**: 無限ループを避けるため、最大3ラウンドで強制終了
- **全結果を渡す**: 各ラウンドで全エージェントの結果を次のラウンドに渡す
- **モデル統一**: Ultra Opus は全て opus、Ultra Sonnet は全て sonnet、Ultra Haiku は全て haiku
- **デバッグ向け**: 実装よりもデバッグ・調査タスクに適している

**Ultra モードが有効なケース**:
- Maximum で解決できなかった問題
- 原因が特定できないバグ
- 複数の専門領域が交差する問題
- 状態遷移、タイミング依存の問題

**Ultra モードが不向きなケース**:
- 単純な機能追加
- 原因が明確なバグ修正
- typo 修正などの軽微な変更

### その他の注意事項

- 各 Phase の専門家エージェントは必ず**並行実行**する（Minimum モード除く）
- 実装モードでは:
  - Phase 0 で要件を明確にする（曖昧なまま進めない）
  - Phase 1.5 で設計書を作成し承認を得る
  - セルフレビューを**5回とも必ず実施**する（省略しない）
- `make lint`, `make build`, `make test` は**必ず実行**する
- モデル変更を含むタスクでは、ドキュメント更新を忘れない
- 収束しない場合は無限ループを避けるため、最大サイクル数を守る
- **モデル指定を忘れない**: 多くのエージェントが opus に昇格している
- **類似コード参照を徹底**: Explore で見つけたパターンを必ず参考にする

---

## 使用例

### 実装モード

```
/forge TextElement に letterSpacing プロパティを追加

→ Phase 0: 要件確認
  「letterSpacing を追加し、UI からも設定可能にする」で合意

→ Phase 1: 6エージェントが並行で調査
  - swift-language-expert: CGFloat プロパティ、Codable 対応を提案
  - swiftui-macos-designer: Text modifier との連携方法を調査
  - research-assistant: Apple の Typography ガイドを参照
  - Explore: 既存の fontSize 実装を発見（TextElement.swift:45-60）
  - architecture-reviewer: Model層への配置を推奨
  - swiftui-test-expert: ラウンドトリップテストの更新が必要と指摘

→ Phase 1.1: クロスレビュー（並行実行）★NEW
  - architecture-reviewer が swift-language-expert の結果をレビュー
    → ✅ 同意: CGFloat は適切
  - swiftui-performance-expert が swiftui-macos-designer の結果をレビュー
    → ⚠️ 要注意: kerning modifier は大量テキストで重くなる可能性
  - swift-language-expert が architecture-reviewer の結果をレビュー
    → ✅ 同意: Model層配置は適切
  - Explore が swiftui-test-expert の結果をレビュー
    → ✅ 同意: ラウンドトリップテスト更新必要
  - swiftui-test-expert が Explore の結果をレビュー
    → 💡 追加: ExportSnapshotTest も更新推奨
  - security-auditor が research-assistant の結果をレビュー
    → ✅ 問題なし

→ 統合エージェントが結果を統合
  - 合意事項: CGFloat, Model層配置, テスト更新
  - 要注意: パフォーマンス（大量テキスト時）
  - 追加タスク: ExportSnapshotTest 更新

→ Phase 1.5: 設計書作成（統合結果に基づく）
  - 参考: fontSize の実装パターン（TextElement.swift:45-60）
  - 変更ファイル: TextElement.swift, TextElementView.swift, TextPropertyPanel.swift
  - 注意: 大量テキスト時のパフォーマンス考慮
  → ユーザー承認取得

→ Phase 2: 実装 + ビルド確認
  - fontSize のパターンに従って letterSpacing を追加
  - make build → 成功

→ Phase 3: セルフレビュー x5
  [省略]

→ Phase 4: 専門家レビュー（6エージェント並行）
  - swift-language-expert: 「Codable の CodingKeys 漏れ」
  - Explore: 「docs/elements.md 未更新」

→ Phase 4.1: クロスレビュー（並行実行）★NEW
  - architecture-reviewer が swift-language-expert の指摘をレビュー
    → ✅ 同意: CodingKeys は必須
  - swiftui-test-expert が Explore の指摘をレビュー
    → ✅ 同意: ドキュメント更新必須

→ Phase 4.2: 統合レビュー★NEW
  統合エージェントが結果を統合:
  ## 統合済みレビュー結果
  ### 🔴 High Priority
  | # | 指摘 | ファイル | 指摘元 | クロスレビュー |
  |---|-----|---------|--------|--------------|
  | 1 | CodingKeys 漏れ | TextElement.swift | swift-language-expert | ✅ 同意 |
  | 2 | docs 未更新 | docs/elements.md | Explore | ✅ 同意 |

→ Phase 2 に戻る（サイクル2）
  - CodingKeys を追加
  - docs/elements.md を更新
  - make lint/build/test → 通過

→ Phase 3-4-4.1-4.2 再実行
  - 統合結果: 指摘なし

→ 完了（2サイクル）
```

### レビューモード

```
/forge Sources/ViewModels/CanvasViewModel.swift

→ Phase 4: 専門家レビュー（6エージェント並行）
  - swift-language-expert: 「42行目: retain cycle の可能性」
  - architecture-reviewer: 「責務が多すぎる、分割推奨」
  - swiftui-performance-expert: 「大量の要素で再描画が重い」

→ Phase 4.1: クロスレビュー（並行実行）★NEW
  - architecture-reviewer が swift-language-expert の指摘をレビュー
    → ✅ 同意: retain cycle は修正必須
  - swift-language-expert が architecture-reviewer の指摘をレビュー
    → ⚠️ 要検討: 分割は大きな変更、段階的に行うべき
  - swiftui-macos-designer が swiftui-performance-expert の指摘をレビュー
    → ✅ 同意: 再描画最適化は必要

→ Phase 4.2: 統合レビュー★NEW
  統合エージェントが結果を統合:
  ## 統合済みレビュー結果
  ### 🔴 High Priority
  | # | 指摘 | クロスレビュー |
  |---|-----|--------------|
  | 1 | retain cycle | ✅ 同意 |
  | 2 | 再描画が重い | ✅ 同意 |
  ### ⚠️ 要検討
  | # | 指摘 | 論点 |
  |---|-----|------|
  | 1 | 責務分割 | 大きな変更のため段階的実施を推奨 |

→ ユーザーに確認（統合結果を提示）
  「High Priority をすべて修正、責務分割は Issue 化」

→ Phase 5: 修正
  - retain cycle を修正
  - 再描画を最適化
  - 責務分割は Issue #XXX として記録
  - make lint/build/test → 通過

→ Phase 4-4.1-4.2: 再レビュー
  - 統合結果: 指摘なし

→ 完了（2サイクル）
```

### Ultra モード（デバッグ）★NEW

```
/forge テキストエレメントをダブルクリックしても編集モードに入れない

→ Phase -1: タスク分析
  - 影響範囲: 複数ファイル（InlineTextFocusManager, InlineTextEditorHost, CanvasContainerView）
  - 複雑度: 高（状態遷移、AppKit-SwiftUI統合）
  - リスク: 中
  💡 推奨: Ultra Sonnet（複数視点の集合知が必要、根本原因特定が困難）
  → ユーザーが Ultra Opus を選択

→ Phase 4: Round 1 - 全エージェント並行分析
  - swift-language-expert: 「非同期処理のタイミング問題の可能性」
  - swiftui-macos-designer: 「NSViewRepresentable のライフサイクル問題の可能性」
  - appkit-swiftui-integration-expert: 「firstResponder の競合の可能性」
  - architecture-reviewer: 「状態管理が複雑すぎる」
  - swift-concurrency-expert: 「DispatchQueue.main.async のタイミング」
  - debugger: 「ログから pendingElementID が設定されていない」

→ Phase 4.3: Round 2 - 再分析（全員の Round 1 結果を入力）
  - swift-language-expert:
    🆕 「debugger の指摘を受けて調査 → requestFocus が呼ばれていない」
  - swiftui-macos-designer:
    🔄 「appkit-swiftui-integration-expert の指摘と合わせると、
        ダブルクリックハンドラから focusManager への伝達が問題」
  - appkit-swiftui-integration-expert:
    🔍 「swift-language-expert の発見を深掘り →
        ダブルクリック時に editingElementID が設定される前に
        View が再描画されている」
  - architecture-reviewer:
    ✅ 「全員が状態遷移の問題で合意しつつある」
  - swift-concurrency-expert:
    💡 「View 更新と focusManager 更新の順序が逆になっている可能性」
  - debugger:
    🎯 「CanvasContainerView.swift:XXX 行で editingElementID を
        設定する前に requestFocus を呼ぶべき」

→ Phase 4.3: Round 3 - 最終確認
  - 全エージェント: ✅ 「debugger の指摘で合意」
  - 収束判定: 新しい発見なし → 収束

→ 統合エージェント: Ultra モード統合結果
  ## 確定した根本原因
  ダブルクリック時の処理順序:
  1. editingElementID を設定 (View 更新トリガー)
  2. requestFocus を呼び出し
  ↓ 問題
  View 更新が先に走り、focusManager がまだ準備できていない

  ## 修正案
  requestFocus を先に呼び、View 更新は focusManager の状態変化で行う

→ Phase 2: 修正
  - CanvasContainerView.swift を修正
  - make build → 成功
  - 動作確認 → 編集モードに入れるようになった

→ 完了（1サイクル、3ラウンド）
```
